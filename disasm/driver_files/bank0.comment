008000 Disable interrupts
008001 Clear NMI and V/H Count, disable joypad
008004 Disable HDMA
008007 Disable DMA
00800A \
00800D  |Clear APU I/O ports 1-4
008010  |
008013 /
008016 \ Turn off screen
008018 /
008018 /
00801B \ Turn off emulation mode
00801C /
00801D 16 bit A,X,Y, Decimal mode off
00801F \ Set direct page
008022 /
008023 \ Set stack location
008026 /
008027 \
00802A  |
00802E  |
008031  |
008034  |
008037  |
00803B  |
00803C  |Create routine in RAM
008040  |
008041  |
008044  |
008045  |
008046  |
008047  |
008048  |
00804A  |
00804C  |
00804E /
00804E /
008052 SPC700 Bank 02 + Main code upload handler
008055 Set game mode to 0
008058 Set secondary game mode to 0
008064 \ Set OAM Size and Data Area Designation to x03
008066 /
008069 Skip the following loop
00806B  |Loop until the interrupt routine sets $10
00806D / to a non-zero value.
00806F Enable interrupts
008070 Increase frame number
008072 The actual game
008075 \ Wait for interrupt
008077 /
008089 Load byte to start transfer
0080E8 \ this address (0E:8000) is the start of the SPC engine
0080EA  | instrument settings/sound effect data
0080ED  | AND the code used for all music banks.
0080EF  |
0080F2  |
0080F4 /
0080FD \
0080FF  |
008102  |Loads The Address 0F:8000 to 00-02 	(SAMPLE DATA + PTRS)
008104  |[SPC Sample Pointers/Data ROM Address, this is]
008104  |[SPC700 Bank 1 (level) music ROM Address, this is]
008107  |
008109 /
00810E \
00810E \
008110  |
008113  |Loads the Bank 1 music data (Map) to 00-02
008113  |Same as above, but for the Bank 2 music data
008115  | ($0E:98B1)
008115  | ($0E:B198)
008118  |
00811A /
008148 \
00814A  |Loads the Bank 2 music address(Levels)
00814D  | (0E:AED6)
00814F  |
008152  |
008154 /
008159 \
00815B  |Bank 3 music(Ending) ROM address
00815E  |
008160  | ($03:E400)
008163  |
008165 /
00816A Looks like this might be the NMI routine here. That is correct.
00816B I thought it was, just from the address, but I wasn't too sure.
008174 8 bit A,X,Y
008176 Load "NMI Enable."  This has the effect of clearing the Interrupt, so that
008179 \
00817C  |
00817E  |
008181  |Update SPC700 I/O port 2
008184  |
008186  |
008189  |
00818C  |
00818F \
008192  |
008195  |
008198  |Update SPC700 I/O ports 0, 1 and 3
00819B  |
00819E  |
0081A1  |
0081A4  |
0081A7 /
0081AA \ Screen off, brightness=0
0081AC /
0081AC /
0081AF Zero The HDMA reg
0081C6 \
0081C9  |If in a "Special level",
0081CB  |jump to $82C4
0081CE \ Get the CGADSUB byte...
0081D0  |Get the Add/Subtract Select and Enable part...
0081D2 / ...and store it to the A/SSaE register...
0081D5 \ 8x8 tiles, Graphics mode 1
0081D7 /
0081DA \ If there isn't any lag,
0081DC / branch to $81E7
0081DE \
0081E1  |If not on a special level, branch to NMINotSpecialLv
0081E2 /
0081F7 \
0081FA  |If the current cutscene isn't the ending,
0081FC / branch to $8209
0081FE \
008201  |Related to reloading the palettes when switching
008203  |to another background during the credits.
008207 /
008246 \
008248  |Set BG 1 Horizontal Scroll Offset
00824B  |to X position of screen boundry
00824D /
008250 \
008252  |
008253  |Set BG 1 Vertical Scroll Offset
008256  |to Y position of screen boundry + Layer 1 disposition
008259  |
00825B  |
00825E /
008261 \
008263  |Set BG 2 Horizontal Scroll Offset
008266  |to X position of Layer 2
008268 /
00826B \
00826D  |Set BG 2 Vertical Scroll Offset
008270  |to Y position of Layer 2
008272 /
008275 \ If in a normal (not special) level, branch
008278 /
00827C \
00827F  |If not playing ending movie, branch to $82A1
008281 /
008283 \
008286 / Set brightness to $0DAE
008289 \
00828C / Set HDMA channel enable to $0D9F
008292 \ IRQ timer, at which scanline the IRQ will be fired.
008294  |(i.e. below the status bar)
008297  |
00829A /
0082A4  \
0082A7   |Set Layer 3 horizontal and vertical
0082AA   |scroll to x00 ; Write twice register
0082AD  /
0082B0 \
0082B3 / Set brightness to $0DAE
0082B6 \
0082B9 / Set HDMA channel enable to $0D9F
0082BC \ Pull all
0082BE  |
0082BF  |
0082C0  |
0082C1  |
0082C2 /
0082C3 And return
0082C4 \ If there is lag,
0082C6 / branch to $82F7
0082CA \ If Mario Start! graphics shouldn't be loaded,
0082CD / branch to $82D4
008374 Set Interrupt flag so routine can start
008375 \ Save A/X/Y/P/B
008376  |P = Processor Flags, B = bank number for all $xxxx operations
008378  |Set B to 0$0
008379  |
00837A  |
00837B  |
00837C  |
00837D /
008380 Read the IRQ register, 'unapply' the interrupt
008383 If "Timer IRQ" is clear, skip the next code block
00838A If Bit 7 (negative flag) is set, branch to a different IRQ mode
00838C Enable NMI Interrupt and Automatic Joypad reading
008394 \ Adjust scroll settings for layer 3
008396  |
008399  |
00839B  |
00839E  |
0083A0  |
0083A3  |
0083A5 /
0083A8 \Set the layer BG sizes, L3 priority, and BG mode
0083AA /(Effectively, this is the screen mode)
0083AD \Write CGADSUB
0083AF /
0083B2 \ Pull everything back
0083B4  |
0083B5  |
0083B6  |
0083B7  |
0083B8 /
0083B9 And Return
0083BA Get bit 6 of $0D9B
0083BD If clear, skip the next code section
0083BF \Skip if $11 = 0
0083C1 /
0083C3 #$81 -> NMI / Controller Enable reg
0083D0 $11++
0083D2 \ Set up the IRQ routine for layer 3
0083D5  |-\
0083D7  |  |Vertical Counter trigger at 174 - $1888
0083D8  |-/ Oddly enough, $1888 seems to be 16-bit, but the
0083DB  |Store to Vertical Counter Timer
0083DE / Make the high byte of said timer 0
0083E1 A = NMI enable, V count enable, joypad automatic read enable, H count disable
0083E3 if $1493 = 0 skip down
0083E8 \ If $1495 is <#$40
0083EB  |
0083ED / Skip down
0083F1 Jump up to IRQNMIEnding
0083F3 A -> NMI/Joypad Auto-Read/HV-Count Control Register
0083F9 \Not often you see NOP, I think there was a JSL here at one point maybe
0083FA /
0083FB \Write Screen register
0083FD /
008400 \ Write L1 Horizontal scroll
008402  |
008405  |
008407 /
00840A \ Write L1 Vertical Scroll
00840C  |
00840F  |
008411 /
008414 And exit IRQ
008416 \
008418 /Write L1 GFX source address
00841B \Write L1/L2 Tilemap address
00841D /
008420 \ Write L1 Horizontal scroll
008422  |
008425  |
008427 /
00842A \ $1C + $1888 -> L1 Vert scroll
00842C  |$1888 = Some sort of vertioffset
00842D  |
008430 /
008433 \Other half of L1 vert scroll
008435 /
008438 Return
008439 <<- Could this be just to waste time?
00843B So... LDY gets set with 20 if there is a H-Blank...?
00843E if in H-Blank, make Y #$20 and try again
008440 Now wait until not in H-Blank
008445  |Y = 0
008446 / ...wait a second... why didn't they just do LDY #$00? ...waste more time?
008448 return
00844E OAM address
008454 Dest. address = $2104 (data write to OAM)
00845A Source address = $00:0200
008460 $0220 bytes to transfer
008465 Start DMA
00846A \
00846C  |
00846F  |Change the OAM read/write address to #$8000 + $3F
008471 /
008474 Return
0084C8 Wrapper
0084D0 Not used?
0084D3 Title screen
0084D6 OW border
0084DC CONTINUE/END
0084E2 1 PLAYER GAME/2 PLAYER GAME
0084E5 OW scroll arrows
0084E8 Remove OW scroll arrows
0084EE CONTINUE AND SAVE
0084F4 Cutscene 1 text: Line 7
0084F7 Cutscene 1 text: Line 6
0084FA Cutscene 1 text: Line 5
0084FD Cutscene 1 text: Line 4
008500 Cutscene 1 text: Line 3
008503 Cutscene 1 text: Line 2
008506 Cutscene 1 text: Line 1
008509 Cutscene 2 text: Line 8
00850C Cutscene 2 text: Line 7
00850F Cutscene 2 text: Line 6
008515 ...etc...
008599 Cutscene border, cave ground
0085A5 Ending: THE END
0085A8 Ending: Enemies: Lakitu
0085AB Ending: Enemies: Hammer Bro.
0085AE Ending: Enemies: Pokey
0085B1 Ending: Enemies: Rex
0085B4 Ending: Enemies: Dino-Rhino
0085B7 Ending: Enemies: Blargg
0085BA Ending: Enemies: Urchin
0085BD Ending: Enemies: Boo
0085C0 Ending: Enemies: Dry Bones
0085C3 Ending: Enemies: Grinder
0085C6 Ending: Enemies: Reznor
0085C9 Ending: Enemies: Mechakoopa
0085CC Ending: Enemies: Bowser
0085D2 12 = Image loader
0085D4 \
0085D7  |
0085D9   |Load pointer
0085D9   |Load pointer
0085D9  |Load pointer
0085DC  |
0085DE   |
0085DE   |
0085DE  |
0085E1 /
0085F7 Do not reload the same thing next frame
008601 Set "VRAM Address Increment Value" to x00
008604 Set "Address for VRAM Read/Write (Low Byte)" to x00
008607 \ Set "Address for VRAM Read/Write (High Byte)" to x50
008609 /
008617 DMA something to VRAM, my guess is a tilemap...
008625 \Change CRAM address
008628  |
00862A /
00862D And Repeat the DMA
008638 \but change desination address to $2119
00863A /
00863D Start DMA
008640 $3B = 0 (not sure what $3B is)
008642 and JSL to a RAM routine
008646 Jump to the next part of this routine
008650 \
008653  |
008655  |
008658  |
008659  |
00865C  |
00865F  |
008662  |
008665  |
008668  |
00866B  |
00866C  |
00866F  |
008672  |
008675  |Read controller data
008678  |
00867B  |
00867D  |
008680  |
008681  |
008684  |
008687  |
00868A  |
00868D  |
008690  |
008693  |
008694  |
008697  |
00869A  |
00869D /
0086A0 \
0086A3  |If $0DA0 is positive, set X to $0DA0
0086A5  |Otherwise, set X to current character
0086A8 \
0086AB  |
0086AD  |
0086B0  |
0086B2  |
0086B5  |Update controller data bytes
0086B7  |
0086BA  |
0086BC  |
0086BF  |
0086C1  |
0086C4 /
0086C6 Return
0086DF "Push" Y
0086E4 16 bit A
0086E6 A = Game mode
0086E9 Multiply game mode by 2
0086F1 A is 16-bit
0086F5 "Pull" Y
0086F7 Jump to the game mode's routine, which has been loaded into $00-02
0086FF 16 bit A,X,Y
008701 \ A = Tileset/byte 3 (TB3)
008704 / Store A in $03
008706 \ Multiply A by 2
008707  |Add TB3 to A
008709 / Set Y to A
00871E 16 bit X,Y
008723 Set index to 0
008726 \ Read line header byte 1
008728  |If the byte & %10000000 is true,
00872A  |Set A,X,Y to 8 bit and return
00872C  |
00872D Store byte in $04
00872F Move onto the next byte
008730 Read line header byte 2
008732 Store byte in $03
008734 Move onto the next byte
008735 Read line header byte 3
008737 \
008739  |Store direction bit in $07
00873A /
00873C \ Set B address (DMA) to x18
00873E /
008741 Re-read line header byte 3
008743 \
008745  |
008746  |Store RLE bit << 3 in $05
008747  |
008748 /
008751 16 bit A
008770 8 bit A
0087AF \
0087B2  |If Layer 1 has to be updated,
0087B4  |jump to $88DD
0087B7 \
0087B9  |
0087BB  |If on a vertical level,
0087BD  |jump to $8849
0087C0 \ Set "VRAM Address Increment Value" to x81
0087C2 /
0087DC \ Enable DMA channel 1
0087DE /
008800 \ Enable DMA channel 1
008803 /
00881E \ Enable DMA channel 1
008820 /
008841 \ Enable DMA channel 1
008843 /
008A79 Set "Screen Initial Settings" to x00
008A7C Turn off mosaic
008AAE \ Set Mode7 "Screen Over" to %10000000, disable Mode7 flipping
008AB0 /
008AB3 Return
008CFF More DMA
008D01 Increment when $2119 accessed
008D04 \VRAM address = #$502E
008D06  |
008D09  |
008D0B /
008D13 Load up the DMA regs
008D16 DMA Source = 8C:8118 (...)
008D17 Dest = $2118, Transfer: #$08 bytes
008D1B Do the DMA
008D1E \ Set VRAM mode = same as above
008D20  |Address = #$5042
008D23  |
008D25  |
008D28  |
008D2A /
008D2D \ Set up more DMA
008D2F  |Dest = $2100
008D32  |Fixed source address = $89:1801 (Lunar Address: 7E:1801)
008D35  |#$808C bytes to transfer
008D36 /Type = One reg write once
008D3A Start DMA
008D3D \prep VRAM for another write
008D3F  |
008D42  |
008D44  |
008D47  |
008D49 /
008D4C \ Load up DMA again
008D4E  |Dest = $2118
008D51  |Source Address = $39:8CC1
008D54  |Size = #$0100 bytes
008D55 /Type = Two reg write once
008D57 \Start Transfer
008D59 /
008D5C \
008D5E  |Set up VRAM once more
008D61  |
008D63  |
008D66  |
008D68 /
008D6B \Last DMA...
008D6D  |Reg = $2118 Type = Two reg write once
008D70  |Source Address = $08:8CF7
008D73  |Size = #$9C00 bytes (o_o)
008D74 /
008D76 \Transfer
008D78 /
008D7B \Copy some data into RAM
008D7D  |
008D7F  |
008D82  |
008D85  |
008D86  |
008D87  |
008D88 /
008D8C #$28 -> Timer frame counter
008D8F Return
008DAC Set VRAM Address Increment Value to x00
008DAF \
008DB1  |Set Address for VRAM Read/Write to x5042
008DB4  |
008DB6 /
008DB9 \
008DBB  |Load settings from DMAdata_StBr1 into DMA channel 1
008DBE  |
008DC1  |
008DC2 /
008DC4 \ Activate DMA channel 1
008DC6 /
008DC9 Set VRAM Address Increment Value to x00
008DCC \
008DCE  |Set Address for VRAM Read/Write to x5063
008DD1  |
008DD3 /
008DD6 \
008DD8  |Load settings from DMAdata_StBr2 into DMA channel 1
008DDB  |
008DDE  |
008DDF /
008DE1 \ Activate DMA channel 1
008DE3 /
008DE6 Return
008DE7 DMA settings for copying the top half
008DEB of the status bar to VRAM
008DEE DMA settings for copying the bottom half
008DF2 of the status bar to VRAM
008E1A \
008E1D  |If level is ending or sprites are locked,
008E1F / branch to $8E6F
008E32 \
008E35  |If time is 0,
008E38  |branch to $8E6F
008E3B /
008E4C \
008E4F  |
008E51  |
008E54  |If time is 99,
008E57  |speed up the music
008E59  |
008E5B  |
008E5D  |
008E60 \
008E63  |
008E66  |If time is 0,
008E69  |JSL to $00F606
008E6B  |
008E6F \
008E72  |
008E75  |Copy time to $0F25-$0F27
008E78  |
008E7B  |
008E7E /
008E9E 16 bit A
008EAE 8 bit A
008EBF 8 bit A
008EC6 \ Store high byte of Mario's score in $00
008EC9 /
008ECB Store x00 in $01
008ECD \ Store mid byte of Mario's score in $03
008ED0 /
008ED2 \ Store low byte of Mario's score in $02
008ED5 /
008EDE \
008EE0  |
008EE3  |
008EE5  |Replace all leading zeroes in the score with spaces
008EE7  |
008EEA  |
008EEB  |
008EED  |
008EEF Get current player
008EF2 If player is Mario, branch to $8F1D
008EF4 \ Store high byte of Luigi's score in $00
008EF7 /
008EF9 Store x00 in $01
008EFB \ Store mid byte of Luigi's score in $03
008EFE /
008F00 \ Store low byte of Luigi's score in $02
008F03 /
008F0C \
008F0E  |
008F11  |
008F13  |Replace all leading zeroes in the score with spaces
008F15  |
008F18  |
008F19  |
008F1B /
008F1D \ If Coin increase isn't x00,
008F20 / branch to $8F3B
008F22 Decrease "Coin increase"
008F25 Increase coins by 1
008F28 \
008F2B  |If coins<100, branch to $8F3B
008F2D /
008F2F Increase lives by 1
008F32 \
008F35  |Decrease coins by 100
008F36  |
008F38 /
008F3B \ If amount of lives is negative,
008F3E / branch to $8F49
008F40 \ If amount of lives is less than 98,
008F42 / branch to $8F49
008F44 \ Set amount of lives to 98
008F46 /
008F49 \
008F4C  |Get amount of lives in decimal
008F4D /
008F50 \
008F51  |If 10s is 0, replace with space
008F53  |
008F55 \ Write lives to status bar
008F58 /
008F5B \ Get bonus stars
008F5E /
008F61 \ If bonus stars is less than 100,
008F63 / branch to $8F73
008F65 \ Start bonus game when the level ends
008F67 /
008F6A \
008F6D  |Subtract bonus stars by 100
008F6E  |
008F70 /
008F73 \ Get amount of coins in decimal
008F76 /
008F79 \
008F7A  |If 10s is 0, replace with space
008F7C  |
008F7E \ Write coins to status bar
008F81 /
008F84 8 bit A
008F86 Load Character into X
009012 8 bit A
009017 16 bit A
009032 8 bit A
009042 8 bit A
009045  |
009047  |
009049  |Sets A to 10s of original A
00904B  |Sets X to 1s of original A
00904D  |
00904E  |
009050 /
009095  Bug: Most sprites have glitched gfx if put in item reserve.  See ItemFix.asm
0091BD \
0091C0  |Set timer to 000
0091C3 /
009235 Set "Address for CG-RAM Write" to 0
009260 Disable all HDMA channels
009263 16 bit A
009265 \
009268  |
00926A  |Clear "HDMA table for windowing effects"
00926D  |...hang on again.  It clears one set of RAM here, but not the same
009270  |
009271  |
009272 /
009274 \ Set A to 8bit and return
009276 /
009291 out?
009294 *note to self: ctrl+insert, not shift+insert*
009296 ...  This is, uh, strange.  It pastes $00FF into the $04A0,x table
009299 instead of $FF00 o_O
0092A0  Enable channel 7 in HDMA, disable all other HDMA channels
0092A2  $7E:0D9F - H-DMA Channel Enable RAM Mirror
0092A8 these are somewhat the same subroutine, but also not >_>
009322 Load game mode
009329 00 -
00932B 01 -
00932D 02 -
00932F 03 -
009331 04 -
009333 05 -
009335 06 -
009337 07 -
009339 08 -
00933B 09 -
00933D 0A -
00933F 0B -
009341 0C -
009343 0D -
009345 0E -
009347 0F -
009349 10 -
00934B 11 -
00934D 12 -
00934F 13 -
009351 14 -
009353 15 -
009355 16 -
009357 17 -
009359 18 -
00935B 19 -
00935D 1A -
00935F 1B -
009361 1C -
009363 1D -
009365 1E -
009367 1F -
009369 20 -
00936B 21 -
00936D 22 -
00936F 23 -
009371 24 -
009373 25 -
009375 26 -
009377 27 -
009379 28 -
00937B 29 -
00937D Disable NMI ,VIRQ, HIRQ, Joypads
009380 Turn off all HDMA
009383 \
009385 /Disable Screen
009385 /Disable Screen
009388 And return
009389 Nintendo Presents X locations
00938D Nintendo Presents tilemap
00939A \ Load Nintendo Presents logo
00939C  |
00939E  |
0093A1  |
0093A4  |   <-Y position of logo
0093A6  |
0093A9  |
0093AC  |
0093AF  |
0093B1  |
0093B4  |
0093B5  |
0093B6  |
0093B7  |
0093B8  |
0093B9 /
0093BB \ Related to making the sprites 16x16?
0093BD /
0093C0 \ Play "Bing" sound?
0093C2 /
0093C5 \ Set timer to x40
0093C7 /
0093CA \ Set brightness to max
0093CC /
0093D4 Sprite palette setting = 0
0093D7 Load the palette
0093DA \ Black background
0093DD /
0093E3 Set menu pointer position to 0
0093E6 Enable sprites, disable layers
0093E8 Set Layer 3 to subscreen
0093EF CGADSUB = 20
0093F1 Apply above settings
0093F4 Move on to Game Mode 01
0093F7 \ Enable NMI and joypad, Disable V-count and H-cout
0093F9 /
0093FD \ Set CGADSUB settings to A
009400 /
009402 Set "Background and Object Enable" to X
009405 Set "Sub Screen Designation" Y
009408 \ Set "Window Mask Designation" for main and sub screen to x00
00940B /
00940E Return
00940F Decrease timer
009412 \ If timer is 0:
009414  |Jump to sub $B888
009417  |Move on to Game Mode 02
00941A Return
009446 \
009448  |Store x80 in $00,
00944A  |Store x70 in $01
00944C /
009450 Background colors to use for cutscenes
009454 Purpose of first byte is unknown
009458 Castle palette to use for cutscenes
00945C Purpose of first byte is unknown
009471 Cutscene number
00950A Change to #$30 to enter debug region below
009510 \ Unreachable
009512  | Debug: Boss defeated scene select
009514  |
009516  |
009519  |
00951A  |
00951C  |
00951E  |
009520  |
009523  |
009525  |
009528 /
0096C6 \ Set title screen music
0096C8 /
0097BE Set brightness to full (RAM mirror)
0097C7 \
0097C9 |Not sure what these bytes are used for yet, unless they're just more
0097CB /scratch (I find that unlikely)
00986A  Y speed = 0
0098A9 \
0098AC  |If "Special level" is even,
0098AD / branch to $98E1
0098B6 16 bit A
0098E1 16 bit A
009922 8 bit A
009A74 \Read old-style controller register for player 1
009A77 /LSR A, but then discard (Is this for carry flag or something?)
009A78 \Load And Rotate left A (player 2 old-style controller regs)
009A7B /
009A7C AND A with #$03
009A7E If A AND #$03 = 0 Then STA $0DA0 (A=0)
009A8A *yawn*
009A91 Zero the timer
009A97 \ Load title screen Layer 3 image
009A99  |
009A9B /
009AA4 todo: NOTE TO SELF: Check this routine out after making Bank4.asm
009AA8 \ Set special level to x01
009AAA /
009AD0 Blinking cursor frame counter (file select, save prompt, etc)
009B80 Wrapper
009BA8 Wrapper
009C6C Zero controller RAM mirror
009C6F (Unknown byte) -> X
009C72 Decrement $1DF5 (unknown byte)
009C75 if !=  0 branch forward
009C77 Load $00/9C20,$1DF4
009C7A And store to $1DF5
009C7E $1DF4+=2
009C82 With the +=2 above, this is effectively LDA $9C20,$1DF4
009C89 If = #$FF, switch to game mode #$02...
009C8E ...And finish
009C91 Write to controller RAM byte 01
009C9A Write to byte 01, Just-pressed variant
009C9C Jump to another section of this routine
009C9F IIRC, this contains a lot of STZ instructions
009CA5 Zero something related to PPU
009CAD Disable all HDMA
009CB2 #$E9 -> Uknown RAM byte
009CB8 -> here
009CBB Increase the Game mode and return (at jump point)
009CD1 16 bit A
009D24 \ Draw 1 PLAYER GAME/2 PLAYER GAME text
009D26  |Increase Game Mode
009D29 /
009D30 Store A in BG color
009D33 Store Y in CGADSUB
009D35 8 bit A
009D41 X =  read index
009D45 Y = write index
009D47 Layer 3-related table
009D4E If not at end of loop, continue
009D5D  $05 = $05 / 2
009F10 \
009F13 |Write overworld settings to OW L1 table
009F16 /
009F22 <- This probably means that the table above ends at 1FB7
009F37 \If 0DB1 = 0 Then Exit Ssub
009F3A /Decrease it either way.
009F3C #$01 -> $0DB1
009F42 \
009F45  |Increase $0DB0 (mosaic size) by $9F31,y
009F46  |
009F49 /
009F4C Load Brightness byte from RAM
009F4F \Add $9F2F,Y
009F50 /
009F53 Store back to brightness RAM byte
009F5B Game Mode += 1
009F5E \
009F61  |$0DAF = $0DAF XOR 1
009F63 /
009F66 \
009F68  |Set mosaic size to $0DB0, enable mosaic on Layer 1 and 2.
009F6B /
009F6E I think we're done here
009F6F Decrement something...  Seems like it might be a timing counter
009F72 If positive, return from subroutine.
009F74 Remain in this mode
009F77 $0DAF -> Y,
009F7A BRA to the fade control routine
009FB8 \
009FBB  |Get (Tileset*3), store in $00
009FBC  |
009FBD  |
009FC0 /
00A153 \ Load overworld border
00A155  |
00A157 /
00A1A6 16 bit X,Y
00A1A8 8 bit A
00A1AA \
00A1AD  |Clear RAM addresses $1A-$D7
00A1AF  |
00A1B0 /
00A1B2 \
00A1B5  |Clear RAM addresses $13D3-$1BA1
00A1B8  |
00A1B9 /
00A1BB 16 bit X,Y
00A1BD Return
00A1C1 Increase alternate frame counter
00A1C7 (Bank 4.asm)
00A249 \ Unreachable
00A24C  | Debug: Slow motion
00A24E  |
00A251  |
00A253  |
00A255  |
00A257  |
00A259 /
00A274 \ Unreachable
00A276  | Debug: Beat level with Start+Select
00A278  |
00A27A /
00A2AF  \ Reset amout to shift level
00A2B2  /
00A2B5  \ If shake ground timer is set
00A2B8   |
00A2BA   | Decrement timer
00A2BD   |
00A2BF   |
00A2C0   |
00A2C3   | $1888-$1889 = Amount to shift level
00A2C6   |
00A2C7   |
00A2C9   | Adjust screen boundry accordingly
00A2CB   |
00A2CE   |
00A2D1   |
00A2D3  /
00A300 16 bit A
00A302 We're using DMA channel 2
00A309 \ Set Address for CG-RAM Write to x86
00A30B /
00A30B /
00A314 \ Get location of palette from $0D82-$0D83
00A317 /
00A317 /
00A31A \ Palette is stored in bank x00
00A31C /
00A31C /
00A31F \ x14 bytes will be transferred
00A322 /
00A322 /
00A325 Transfer the colors
00A328 \ Set VRAM Address Increment Value to x80
00A32A /
00A32A /
00A33F \ Set bank to x7E
00A341 /
00A341 /
00A344 \ x20 bytes will be transferred
00A347 /
00A347 /
00A34A Transfer
00A34D \ Set Address for VRAM Read/Write to x6000
00A350 /
00A350 /
00A355 \ Get address of graphics to copy
00A358 /
00A358 /
00A35B \ x40 bytes will be transferred
00A35E /
00A35E /
00A361 \ Transfer
00A363 /
00A363 /
00A366 \ Move to next address
00A367 /
00A368 \ Repeat last segment while X<$0D84
00A36B /
00A36D \ Set Address for VRAM Read/Write to x6100
00A370 /
00A370 /
00A375 \ Get address of graphics to copy
00A378 /
00A378 /
00A37B \ x40 bytes will be transferred
00A37E /
00A37E /
00A381 \ Transfer
00A383 /
00A383 /
00A386 \ Move to next address
00A387 /
00A388 \ Repeat last segment while X<$0D84
00A38B /
00A38D 8 bit A
00A38F Return
00A43E 16 bit A
00A47C 8 bit A
00A594 Wrapper
00A59C gah, stupid keyboard >_<
00A5AB ->here
00A5B4 Working on this routine
00A635  If blue pow...
00A638  ...or silver pow...
00A640 \ Branch if Mario doesn't have star
00A643 /
00A654  Zero out POW timer
00A657  Zero out silver POW timer
00A65D Zero out star timer
00A709  \ Animation = Rise off screen,
00A70B  / for Yoshi Wing bonus stage
00A711  \ Set upward speed, #$90
00A713  /
00A768  \ Set downward speed, #$1C
00A76A  /
00A7C2 16 bit A
00A82A 8 bit A
00A8C3 Forest
00A8C7 Castle
00A8CB Mushroom
00A8CF Underground
00A8D3 Water
00A8D7 Pokey
00A8DB Underground 2
00A8DF Ghost House
00A8E3 Banzai Bill
00A8E7 Yoshi's House
00A8EB Dino-Rhino
00A8EF Switch Palace
00A8F3 Mechakoopa
00A8F7 Wendy/Lemmy
00A8FB Ninji
00A8FF Unused
00A92B Normal 1
00A92F Castle 1
00A933 Rope 1
00A937 Underground 1
00A93B Switch Palace 1
00A93F Ghost House 1
00A943 Rope 2
00A947 Normal 2
00A94B Rope 3
00A94F Underground 2
00A953 Switch Palace 2
00A957 Castle 2
00A95B Cloud/Forest
00A95F Ghost House 2
00A963 Underground 2
00A993 \
00A996  |Set "Address for VRAM Read/Write" to x4000
00A998 /
00A9C4 \
00A9C7  |Set "Address for VRAM Read/Write" to x6000
00A9C9 /
00A9DA Decompression as well?
00A9DC VRAM transfer control port
00A9E1 $192B = current sprite GFX list index
00A9E4 \
00A9E5  }4A -> Y
00A9E6 /
00A9E7  |
00A9EA  |
00A9EC  |
00A9ED  |
00A9EE /
00A9F0 #$03 -> A -> $0F
00A9F4 $0F -> X
00A9F6 #$00 -> $2116
00A9F9 My guess: Locations in VRAM to upload GFX to
00A9FC Set VRAM address to $??00
00A9FF Y is possibly which GFX file
00AA01 to upload to a section in VRAM, used in
00AA04 the subroutine $00:BA28
00AA06 don't upload when it''s not needed
00AA08 JSR to a JSL...
00AA0B Decrement $0F
00AA0D if >= #$00, continue transfer
00AA0F \
00AA11  |Update $0101-$0104 to reflect the new sprite GFX
00AA13  |That's loaded now.
00AA16  |
00AA17 /
00AA19 LDA Tileset
00AA1E Branch to a routine that uploads file #$80 to every slot in FG/BG
00AA22 this routine is pretty close to the above
00AA25 one, I'm guessing this does
00AA26 object/BG GFX.
00AA27 4A -> Y
00AA28 FG/BG GFX table
00AA2F FG/Bg to upload -> $04 - $07
00AA33 #$03 -> $0F
00AA35 $0F -> X
00AA3A Load + Store VRAM upload positions
00AA42 Check to see if the file to be uploaded already
00AA45 exists in the slot in VRAM - if so,
00AA47 don't bother uploading it again.
00AA49 Upload the GFX file
00AA4C Next GFX file
00AA5A Return from uploading the GFX
00AA5B If zero flag set, don't update the tileset
00AA62 my guess is that it gets called in the same set of routines
00AA6A Return
00AA76 handle the post-special world graphics and koopa color swap.
00AA80 A = 16bit
00AA85 LDX Tileset
00AA88 CPX #$11
00AA8A If Tileset < #$11 skip to lower area
00AA8C if Y = #$08 skip to JSR
00AA90 If Y = #$1E then
00AA92 JMP otherwise
00AA94 don't JMP
00AB01 Return
00AB09 \Completely pointless code.
00AB0B /(Why not just NOPing it out, Nintendo?)
00AB0F \ Okay, so take [$00], store
00AB11  |it to VRAM, then bitwise
00AB14  |OR the high and low bytes together
00AB15  |store in both bytes of A
00AB17 /and store to $1BB2,x
00AB1A \Increment $7E:0000 by 2
00AB1C /
00AB1E \And continue on another 7 times (or 8 times total)
00AB1F /
00AB21 hm..  It's like a FOR Y{FOR X{ } } thing ...yeah...
00AB25 A normal byte becomes 2 anti-compressed bytes.
00AB28 I'm going up, to try and find out what's supposed to set $00-$02 for this routine.
00AB2A AHA, check $00/BA28.  It writes a RAM address to $00-$02, $7EAD00
00AB2C So...  Now to find otu what sets *That*
00AB2D ...this place gives me headaches... Can't we work on some other code? :(
00AB30 Sure, go ahead.  anyways, this seems to upload the decompressed GFX
00AB32 while scrambling it afterwards (o_O).
00AB34 Okay... WHAT THE HELL?
00AB37 I'll have nightmares about this routine for a few years. :(
00AB3A Ouch.
00AB41 Return
00ABC3 Return
00ABD2 Return
00ABED 16 bit A, X and Y
00ABEF \
00ABF2  |Set color 1 in all object palettes to white
00ABF4  |
00ABF7 /
00ABFA \
00ABFD  |Set color 1 in all sprite palettes to white
00ABFF  |
00AC02 /
00AC05 \
00AC08  |
00AC0A  |Load colors 8-16 in the first two object palettes from 00/B170
00AC0D  |(Layer 3 palettes)
00AC0F  |
00AC12  |
00AC14  |
00AC17  |
00AC19 /
00AC1C \
00AC1F  |
00AC21  |Load colors 2-7 in palettes 4-D from 00/B250
00AC24  |(Object and sprite palettes)
00AC26  |
00AC29  |
00AC2B  |
00AC2E  |
00AC30 /
00AC33 \
00AC36  |
00AC39  |Load background color
00AC3A  |
00AC3B  |
00AC3E /
00AC41 \Store base address in $00, ...
00AC44 /
00AC46 \...get current object palette, ...
00AC49 /
00AC4C \
00AC4D  |
00AC50  |...use it to figure out where to load from, ...
00AC53  |
00AC54  |...add it to the base address...
00AC56 / ...and store it in $00
00AC58 \
00AC5B  |
00AC5D  |
00AC60  |Load colors 2-7 in object palettes 2 and 3 from the address in $00
00AC62  |
00AC65  |
00AC67 /
00AC6A \Store base address in $00, ...
00AC6D /
00AC6F \...get current sprite palette, ...
00AC72 /
00AC75 \
00AC76  |
00AC79  |...use it to figure out where to load from, ...
00AC7C  |
00AC7D  |...add it to the base address...
00AC7F / ...and store it in $00
00AC81 \
00AC84  |
00AC86  |
00AC89  |Load colors 2-7 in sprite palettes 6 and 7 from the address in $00
00AC8B  |
00AC8E  |
00AC90 /
00AC93 \Store bade address in $00, ...
00AC96 /
00AC98 \...get current background palette, ...
00AC9B /
00AC9E \
00AC9F  |
00ACA2  |...use it to figure out where to load from, ...
00ACA5  |
00ACA6  |...add it to the base address...
00ACA8 / ...and store it in $00
00ACAA \
00ACAD  |
00ACAF  |
00ACB2  |Load colors 2-7 in object palettes 0 and 1 from the address in $00
00ACB4  |
00ACB7  |
00ACB9 /
00ACBC \
00ACBF  |
00ACC1  |
00ACC4  |
00ACC6  |Load colors 9-F in object palettes 2-4 from 00/B674
00ACC9  |
00ACCB  |
00ACCE  |
00ACD0 /
00ACD3 \
00ACD6  |
00ACD8  |
00ACDB  |
00ACDD  |Load colors 9-F in sprite palettes 1-3 from 00/B674
00ACE0  |
00ACE2  |
00ACE5  |
00ACE7 /
00ACEA 8 bit A, X and Y
00ACEC Return
00ACFE Return
00AD1D Return
00ADA5 Return
00ADD8 Return
00AE14 Return
00AE40 Return
00AE64 Return
00AFA2 Return
00AFBF Return
00B005 Return
00B03D Return
00B090 Return
00B88A \
00B88D  |Store the address 08/BFC0 at $8A-$8C
00B88F  |
00B891 /
00B893 \
00B896  |Store the address 7E/2000 at $00-$02
00B898  |
00B89A /
00B89F \
00B8A1  |
00B8A3  |Store the address 7E/ACFE at $8D-$8F
00B8A5  |
00B8A8 /
00B8E0 \
00B8E3  |
00B8E6  |If the next byte is xFF, return.
00B8E8  |Compressed graphics files ends with xFF IIRC
00B8EA  |
00B8EC /
00B8EC /    Return
00B983 Read the byte
00B985 \ Go to next byte
00B987  |
00B988  |   \
00B98A  |    |Handle bank crossing
00B98D  |   /
00B98F /
00B991 Return
00BA4C Return
00BEF6  Set low byte of pointer
00BEFC  Set middle byte of pointer
00BF02  High byte of pointer = #$00
00BFBB Return
00BFC5 $9C - Tile generated
00BFC9 01 - empty space
00BFCB 02 - empty space
00BFCD 03 - vine
00BFCF 04 - tree background, for berries
00BFD1 05 - always turning block
00BFD3 06 - coin
00BFD5 07 - Mushroom scale base
00BFD7 08 - mole hole
00BFD9 09 - invisible solid
00BFDB 0a - multiple coin turnblock
00BFDD 0b - multiple coin q block
00BFDF 0c - turn block
00BFE1 0d - used block
00BFE3 0e - music block
00BFE5 0f - music
00BFE7 10 - all way music block
00BFE9 11 - sideways turn block
00BFEB 12 - tranlucent
00BFED 13 - on off
00BFEF 14 - side of pipe, left
00BFF1 15 - side of pipe, right
00BFF3 16 - used
00BFF5 17 - O block from 1up game
00BFF7 18 - invisible block containing wings
00BFF9 19 - cage
00BFFB 1a - cage
00BFFD 1b -
00C062 Return
00C08C \ X = index of tile to generate
00C08E  |
00C091 /
00C094 \ Reset #$01 bit
00C096  |
00C098 /
00C09A \ Store tile
00C09E /
00C0D9 \ X = index of tile to generate
00C0DB  |
00C0DC  |
00C0DF  |
00C0E2 /
00C0E5 \ Set #$01 bit
00C0E7  |
00C0E9 /
00C0EB \ Store tile
00C0EF /
00C1AB Return
00C29D Return
00C3D0 Return
00C452 Return
00C4F8  Bug: Crash?  Should clear $13FB if animation is in progress ($71 non-zero).  See fireberryfix.asm
00C500 \ Branch if sprites locked
00C502 /
00C527 / Change music
00C527 / Play sound effect
00C54C / Change music
00C54C / Play sound effect
00C557 \ Play sound effect
00C559 /
00C559 / Play sound effect
00C576 Change to BEQ to reach debug routine below
00C578 \ Unreachable
00C57A  | Debug: Cycle through powerups
00C57B  |
00C57D  |
00C57F  |
00C581  |
00C583 /
00C592 Return
00C599 0 - Reset                  
00C59B 1 - Power down             
00C59D 2 - Mushroom power up      
00C59F 3 - Cape power up          
00C5A1 4 - Flower power up        
00C5A3 5 - Door/Horizontal pipe exit
00C5A5 6 - Vertical pipe exit     
00C5A7 7 - Shot out of diagonal pipe
00C5A9 8 - Yoshi wings exit       
00C5AB 9 - Mario Death            
00C5AD A - Enter Castle           
00C5AF B - freeze forever         
00C5B1 C - random movement??      
00C5B3 D - freeze forever         
00C6F0 \ Branch if Mario has upward speed
00C6F2 /
00C720 \ Play sound effect
00C722 /
00C722 / Play sound effect
00C732 \ Play sound effect
00C734 /
00C734 / Play sound effect
00C75F \ Play sound effect
00C761 /
00C761 / Play sound effect
00C798 \ Play sound effect
00C79A /
00C79A / Play sound effect
00C7AC \ Play sound effect
00C7AE /
00C7AE / Play sound effect
00C7D1 \ Play sound effect
00C7D3 /
00C7D3 / Play sound effect
00C7F8 Return
00C807  \ Branch if Mario has downward speed
00C809  /
00C80B  \ Branch if Y speed < #$90
00C80D  /
00C80F  \ Y Speed -= #$0D
00C810   |
00C812  /
00C90F \ Play sound effect
00C911 /
00C911 / Play sound effect
00C914 Return
00C96A Return
00C9BE / Change music
00C9BE / Play sound effect
00C9C1 Return
00C9D1  \ Branch if Goal Tape extra bits == #$02
00C9D4   | (never happens)
00C9D5   |
00C9D7  /
00C9D9  \ Unreachable
00C9DB   | Set submap to be Yoshi's Island
00C9DE  /
00C9FE  Store secret/normal exit info
00CA30 Return
00CA31  \ Mario's image = Peace Sign, or
00CA33   |
00CA36   |
00CA38   | Mario's image = Peace Sign on Yoshi
00CA3A  /
00CA3D Return
00CA43 Return
00CA49 Return
00CA60 Return
00CA61 16 bit A
00CA63 \
00CA66  |Load xCB12 into $04 and $06
00CA68 /
00CA6A 8 bit A
00CA6C Return
00CA6C Return
00CA88 16 bit A
00CA8A Keep lower byte of A
00CA8D \
00CA8E  |Set Y to ((2A-1)*2)
00CA8F  |
00CA90 /
00CA91 8 bit A
00CB11 Return
00CC5B Return
00CC84 Change to BEQ to enable debug code below
00CC86 \ Unreachable
00CC87  | Debug: Free roaming mode
00CC89  |
00CC8B  |
00CC8E  |
00CC90  |
00CC92  |
00CC93  |
00CC94  |
00CC96  |
00CC99  |
00CC9B  |
00CC9D  |
00CC9F  |
00CCA1  |
00CCA3  |
00CCA5  |
00CCA6  | Accum (16 bit)
00CCA8  |
00CCAA  |
00CCAB  |
00CCAE  |
00CCB0  | Accum (8 bit)
00CCB2 / Return
00CCB2 Return
00CCC6 \ Branch if sprites locked
00CCC8 /
00CCD0  \ If lock Mario timer is set...
00CCD3   |
00CCD5   | Decrease the timer
00CCD8   | X speed = 0
00CCDA   | Mario's image = Going down tube
00CCDC  /
00CCDF Return
00CD24  \ Branch if Mario has downward speed
00CD26  /
00CD2E  Y speed = 0
00CD94 Return
00CDA3  \ Mario's image = Going down tube
00CDA5  /
00CDC4  \ Mario's image = Picking up object
00CDC6  /
00CDC9 \ Check Yoshi wing ability address for #$01,
00CDCC / but this is an impossible value
00CDCE \ Unreachable/unused code
00CDD0  | Lets Mario (any power) shoot fireballs while on Yoshi
00CDD2  |
00CDD4  |
00CDD6  |
00CDD9 /
00CDDC Return
00CDF6 \ Branch if anything besides L/R being held
00CDF8  |
00CDFA  |
00CDFC /
00CDFE \ Branch if L/R not being held
00CE00  |
00CE02  |
00CE04  |
00CE06 /
00CE3F \ Play sound effect
00CE41 /
00CE41 / Play sound effect
00CEB1 Related to cape animation?
00CEB6 Cape image
00CEB9 If Mario isn't in air, branch to $CEDE
00CEBB branch to $CEDE
00CEBF \ If Mario is falling (and thus not on ground)
00CEC1 / branch down
00CEC3 \ If making a "run jump",
00CEC5 / branch to $CEFD
00CEC7 \ If Mario is in water,
00CEC9  |branch to $CEFD
00CECB / otherwise, branch to $CEE4
00CECD \
00CECE  |if X >= #$04 and != #$FF then jump down <- counting the INX
00CED0 /
00CED2 X = #$05
00CED4 Branch to $CF04
00CED6 \ If X is less than #$0B,
00CED8 / branch to $CF0A
00CEDA X = #$07
00CEDC Mario is not in the air, branch to $CF0A
00CEDE \ If Mario X speed isn't 0,
00CEE0 / branch to $CEF0
00CEE2 Otherwise Y = #$08
00CEE4 A = X = #13DF
00CEE5 If $13DF (now A) = 0 branch to $CF04
00CEE7 \
00CEE8  |If X - 1 < #$03 Then Branch $CF04
00CEEA /
00CEEC X = #$02
00CEEE Branch to $CF04
00CEF0 \
00CEF2  |A = abs(A)
00CEF4  |
00CEF5 \
00CEF6  |Divide a by 8
00CEF7 /
00CEF8 Y = A
00CEF9 A = Mario animation speed? (I didn't know it was a table...)
00CEFC Load Y with this table
00CEFD \
00CEFE  |
00CF00  |If X is < #$02 and != #$FF <- counting the INX
00CF02  |then X = #$05
00CF04 \
00CF06  |If X is greater than or equal to #$07 then X = #$03
00CF08  |
00CF0A And X goes right back into $13DF (cape image) after being modified
00CF0D Now Y goes back into A
00CF0E \
00CF10  |If mario is in water then A = 2A
00CF12  |
00CF13 A -> $14A2 (do we know this byte yet?) no.
00CF16 A = Spin Jump Flag
00CF1C If $140D OR $14A6 = 0 then branch to $CF4E
00CF1E 0 -> Ducking while jumping flag
00CF20 \
00CF22  |X = Y = Alternate frame counter AND #$06
00CF24  |
00CF25 /
00CF26 \ If on ground branch down
00CF28 /
00CF2A \ If Mario moving upwards branch down
00CF2C /
00CF2E Y = Y + 1
00CF2F \ After loading from this table,
00CF32 / Store A in cape image
00CF35 A = Mario's powerup status
00CF37 \
00CF39  |If not small, increase X
00CF3A \ Load from another table
00CF3D / store to Mario's Direction
00CF3F \
00CF41  |
00CF43  |If Mario has cape, JSR
00CF45  |to possibly the graphics handler
00CF48 \ Load from a table again
00CF4B / And jump
00CF4E \ If $13ED is #$01 - #$7F then
00CF51  |branch to $CF85
00CF53  |
00CF62 \ Select Case $148F
00CF64  |Case 0:A = #$3C
00CF67  |Case Else: A = #$1D
00CF69  |End Select
00CF6B \ If Ducking while jumping
00CF6D / Branch to $CF85
00CF6F \ If (Unknown) = 0
00CF72 / Branch to $CF7E
00CF74 A = #$3F
00CF76 \ If Mario isn't in air,
00CF78  |branch to $CF85
00CF7A  |Otherwise, set A to #$16 and
00CF7C / branch to $CF85
00CF7E A = #$0E
00CF80 \ If Time to show Mario's current pose is 00,
00CF83  | Don't jump to $D01A
00CF85  |
00CF88 A = #$1D
00CF8A \ If $1499 != 0 then Jump to $D01A
00CF8D /
00CF8F A = #$0F
00CF91 \ If $1499 != 0 then Jump to $D01A
00CF94 /
00CF96 A = #$00
00CF98 X = $18C2 (Unknown)
00CF9B If X != 0 then branch down
00CF9D \ If Mario is flying branch down
00CF9F /
00CFA1 \ If $14A0 != 0 then
00CFA4 / Skip down
00CFA6 Spaghetticode(tm)
00CFAE \ If Mario isn't holding something,
00CFB1  |branch to $D01A
00CFB3  |Otherwise, set A to #$09 and
00CFB5 / branch to $D01A
00CFBC \
00CFBE  |
00CFC0  |Set A to absolute value of Mario's X speed
00CFC2  |
00CFC3 Copy A to X
00CFC4 If Mario isn't standing still, branch to $CFD4
00CFC6 "Push" A
00CFC7 \
00CFC9  |If player isn't pressing up,
00CFCB  |branch to $D002
00CFCD  |Otherwise, store x03 in $13DE and
00CFCF  |branch to $D002
00CFD2 /
00CFD4 \ If level isn't slippery,
00CFD6 / branch to $CFE3
00CFE3 A = $13DB
00CFE6 \ If Mario is hurt (flashing),
00CFE9 / branch to $D003
00CFEB A = A - 1
00CFEC \If bit 7 is clear,
00CFEE  | Load amount of walking frames
00CFF0  | for current powerup
00CFF3 \ >>-This code puts together an index to a table further down-<<
00CFF4  |-\ Above Line: "Push" frame amount
00CFF5  |  |A = X / 8
00CFF6  |  |
00CFF7  |-/
00CFF8  |ORA with $13E5
00CFFB  |And store A to Y
00CFFC  |
00CFFF /
00D002 \ Switch in frame amount and store it to $13DB
00D003 /
00D006 \ Add walking animation type
00D007 / (Walking, running...)
00D00A \
00D00D  |
00D00F  |If Mario is carrying something, add #$07
00D010  |
00D012  |
00D014 \
00D016  |If X is greater than #$2F, add #$04
00D018 / <-Carry is always set here, adding #$01 to (#$03 + A)
00D01A \ If Mario isn't rotated 45 degrees (triangle
00D01D / block), branch to $D030
00D01F \ Y AND #$01 -> Mario's Direction RAM Byte
00D020  |
00D022 /
00D024 \
00D026  |If Y < 6 then
00D028  |    A = #13DB + $11
00D02A  |Else
00D02D  |    A = #$10
00D02E  |End If
00D030 Store in Current animation frame
00D033 And Finish
00D033 And Finish   Return
00D04B 16 bit A
00D04D \
00D04F  |
00D050  |
00D053  |Set cape<->sprite collision coordinates
00D056  |
00D058  |
00D059  |
00D05C /
00D05F 8 bit A
00D061 Return
00D061 Return
00D07B \ Play sound effect
00D07D /
00D07D / Play sound effect
00D080 Return
00D0AA haha, I read this as "FEAR" at first
00D0AD Return
00D0B6 Set powerup to 0
00D0B8 \
00D0BA / Set Mario image to death image
00D0BD \
00D0BF  |Decrease "Death fall timer" every four frames
00D0C1  |
00D0C3  |
00D0C6 \ If Death fall timer isn't #$00,
00D0C9 / branch to $D108
00D0D5 Set reserve item to 0
00D0D8 Decrease amount of lifes
00D0DB If not Game Over, branch to $D0E6
00D0DF / Change music
00D0DF / Play sound effect
00D0E2 Set X (Death message) to x14 (Game Over)
00D0E6 Set Y (game mode) to x0B (Fade to overworld)
00D0E8 \
00D0EB  |If time isn't zero,
00D0EE  |branch to $D104
00D0F1 /
00D0F3 Set X (Death message) to x1D (Time Up)
00D0F5 Store X in Death message
00D0F8 \ Set Death message animation to xC0
00D0FA /(Must be divisable by 4)
00D0FD \ Set Death message timer to xFF
00D0FF /
00D102 Set Y (game mode) to x15 (Fade to Game Over)
00D104 Store Y in Game Mode
00D107 Return
00D108 \ If Death fall timer >= x26,
00D10A / return
00D10C Set Mario X speed to 0
00D114 \
00D116  |
00D117  |Flip death image every four frames
00D118  |
00D11A /
00D131  \ Set Mario's image
00D134  /
00D13F Return
00D15E Return
00D18C Return
00D1AD  \ Mario's image = Entering horizontal pipe on Yoshi
00D1AF  /
00D212 \
00D214  | If not relativly centered on the pipe...
00D216  |
00D218  |
00D21B  |
00D21D  |
00D21F  |
00D220  | ...adjust Mario's X postion
00D222  |
00D223  |
00D226 /
00D228 \ Mario's image = going down pipe
00D22A /
00D22D \ Set holding X/Y on controller
00D22F /
00D231 \ Set behind scenery flag
00D233 /
00D24E \ If Mario has no speed...
00D250  |
00D252  |
00D254  | ...play sound effect
00D256 /
00D256 / Play sound effect
00D259 \ Set X speed
00D25C /
00D25E \ Set Y speed
00D261 /
00D263 Mario flying = false
00D26A \ In new level, reset values
00D26D /
00D27B Return
00D27C \ Unreachable
00D27E  |
00D27F  |
00D281  |
00D282  |
00D284  |
00D286 / Return
00D286 Return
00D2A5 \ Play sound effect
00D2A7 /
00D2A7 / Play sound effect
00D2B0  Set sprites not locked
00D2B2  \ X speed = #$40
00D2B4  /
00D2B6  \ Y speed = #$C0
00D2B8  /
00D649 \ Play sound effect
00D64B /
00D64B / Play sound effect
00D65E \ Play sound effect
00D660 /
00D660 / Play sound effect
00D7A4 Return
00D8A8 \ Play sound effect
00D8AA /
00D8AA / Play sound effect
00D8CD \ Branch if not flying
00D8CF /
00D8D1 X = #$00
00D8D3 \ Branch if not on Yoshi
00D8D6 /
00D8D8 \ Branch if not winged Yoshi
00D8DB  |
00D8DC /
00D8DE \ Branch if not Caped Mario
00D8E0  |
00D8E2 /
00D8E4 X= #$01
00D8E7 \ Branch if not Caped Mario
00D8E9  |
00D8EB /
00D8ED \ Branch if $72 != 0C
00D8EF  |
00D8F1 /
00D930 \ If Mario's Y speed is negative (up),
00D932 / branch to $D948
00D94E Return
00D967 Return
00D97F Return
00DA8C Return
00DAA8 Return
00DAA9 \ Play sound effect
00DAAB /
00DAAB / Play sound effect
00DAB6 Return
00DB95 Return
00DB96 Mario is in Water flag
00DBA5 \ Play sound effect
00DBA7 /
00DBA7 / Play sound effect
00DBB2 \ Play sound effect
00DBB4 /
00DBB4 / Play sound effect
00DBBA Mario X
00DBC3 Mario's Direction
00DBCD Store A in Mario image
00DBF2 \
00DBF4  |If up or down isn't pressed, branch to $DC16
00DBF6 /
00DBF8 \ If up is pressed, branch to $DC03
00DBFA /
00DC00 Mario isn't climbing
00DC02 Return
00DC02 Return
00DC2C Return
00DC2D \ Store Mario's Y speed in $8A
00DC2F /
00DC4E Return
00DC77 Return
00E2CF \ Branch if Mario doesn't have star
00E2D2 /
00E2E0 Decrease star timer
00E305 / Change music
00E305 / Play sound effect
00E384 Return
00E45C Return
00E4B8 Return
00E9A0 Return
00EA8D \ Play sound effect
00EA8F /
00EA8F / Play sound effect
00EAA5 Return
00EAB8 Return
00EB21 Return
00EB41 Return
00EB76 Return
00EC10 \ Play sound effect
00EC12 /
00EC12 / Play sound effect
00EC5B Current MAP16 tile number
00EC83 Current MAP16 tile number
00EC98 Current MAP16 tile number
00ED06 Current MAP16 tile number
00ED09 \ If block is turn block, branch to $ED3B
00ED0B /
00ED41 / Play sound effect
00ED47 / Play sound effect
00EE06 $ED3B
00EE1D \ If Mario isn't on a sprite platform,
00EE20 / branch to $EE2D
00EE22 \ If Mario is moving up,
00EE24 / branch to $EE2D
00EE2D \
00EE2F  |If Mario is on an edge or in air,
00EE31  |branch to $EE39
00EE33 /
00EE35 \ Set "In air" to x24 (falling)
00EE37 /
00EE39 Return
00EE3A Current MAP16 tile number
00EE3D Tileset
00EE40 \ If tileset is "Rope 1",
00EE42 / branch to $EE48
00EE44 \ If tileset isn't "Rope 3",
00EE46 / branch to $EE57
00EE48 \
00EE49  |If the current tile isn't Rope 3's "Conveyor rope",
00EE4A  |branch to $EE57
00EE4C  |
00EE4E /
00EE5C Current MAP16 tile number
00EE5F \ If block isn't "Turn block",
00EE61 / branch to $EE78
00EE78 \ If block isn't "Brown block",
00EE7A / branch to $EE7F
00EE85 \ If Mario isn't moving up,
00EE87 / branch to $EE8F
00EEAE \ If switch block is already active,
00EEB1 / branch to $EED1
00EEB3 \ Activate switch block
00EEB4 /
00EEC4 / Change music
00EEC4 / Play sound effect
00EEC7 \
00EEC9 / Set music to xFF
00EF87 \ If Yoshi has stomp ability,
00EF8A  |
00EF8C  | Run routine
00EF90  | Play sound effect
00EF92 /
00EF92 / Play sound effect
00EF98 Return
00EFAD Return
00EFB6 \ Play sound effect
00EFB8 /
00EFB8 / Play sound effect
00EFBB Return
00EFE7 Return
00F004 Return
00F026 / Play sound effect
00F04C Return
00F05B Return
00F15E Return
00F175 Return
00F1C9 \ Branch if Mario has star
00F1CC /
00F1F8 Return
00F238 / Play sound effect
00F23F \ Set data bank = $02
00F241  |
00F252 \ Block to generate = Used block
00F254 /
00F281 \ Block to generate = #$02
00F283 /
00F28B Return
00F2BF Return
00F2C8 Return
00F2CD \ Block to generate = #$02
00F2CF /
00F2EA / Play sound effect
00F2ED Return
00F308 Return
00F32B YOSHI COIN HANDLER
00F35A / Play sound effect
00F36B \ Block to generate = #$01
00F36D /
00F376 Return
00F3B1 Return
00F3C3 Return
00F43B / Play sound effect
00F442 Return
00F44C Return
00F464 Return
00F4A5 Return
00F4E6 Return
00F548 Load MAP16 tile number
00F54B \ If block isn't "Invisible POW ? block",
00F54D / branch to PSwitchNotInvQBlk
00F559 Return
00F55A \ If block is "Coin",
00F55C / branch to PSwitchCoinBrown
00F576 Return
00F583 Return
00F594 Return
00F5B6 Return
00F5B7 \ Return if animation sequence activated
00F5B9 /
00F5BB \ If flashing...
00F5BE  | ...or have star...
00F5C1  | ...or level ending...
00F5C4 / ...return
00F5D5 \ If Mario is small, kill him
00F5D7 /
00F5D9 \ Branch if not Caped Mario
00F5DB /
00F5DD \ Branch if not soaring
00F5E0 /
00F5E2 \ Break Mario out of soaring
00F5E4  | (Play sound effect)
00F5E4 / Play sound effect
00F5E7  | (Set spin jump flag)
00F5E9  |
00F5EC  | (Set flashing timer)
00F5EE /
00F5F3 \ Play sound effect
00F5F5 /
00F5F5 / Play sound effect
00F5FC \ Set power down animation
00F5FE /
00F600 Mario status = Small
00F606 \ Mario Y speed = #$90
00F608 /
00F60A \
00F60C / Change music
00F60C / Play sound effect
00F614 \ Animation sequence = Kill Mario
00F616 /
00F618 Spin jump flag = 0
00F61D Set hurt frame timer
00F620 set lock sprite timer
00F622 Cape status = 0
00F628 Return
00F62D Zero RAM mirrors for controller Input
00F635 Return
00F69E Return
00F7F3 Return
00F7F9 Return
00F833 \ If winged Yoshi...
00F836  |
00F83A  | ...or climbing
00F84F \ Branch if 141E >= #$02
00F852  |
00F854 /
00F8AA Return
00F8DE Return
00F91B / Play sound effect
00F94D Return
00F9C8 Return
00F9F4 Return
00FA10 \ Unreachable
00FA10 \ Unused code:
00FA12  | Clear out sprite status table
00FA15  |
00FA16  |
00FA18 /
00FA18 Return
00FA44 Return
00FA45 \ Set "Time to shake ground" to x20
00FA47  /
00FA47  /
00FA47 /
00FA4A \
00FA4C  |Set sprite x02 to x60 (Flat palace switch)
00FA4E /
00FA51 \ Set sprite's status to x08
00FA53 /
00FA56 \
00FA58  |Set sprite X (low) to $9A & 0xF0
00FA5A /
00FA5D \ Set sprite X (high) to $9B
00FA5F /
00FA62 \
00FA64  |
00FA66  |Set sprite Y (low) to ($98 & 0xF0) + 0x10
00FA67  |
00FA69 /
00FA6C \
00FA6E  |Set sprite Y (high) to $99 + carry
00FA70 / (Carry carried over from previous addition)
00FA7A \ Set sprite's "Spin Jump Death Frame Counter" to x5F
00FA7C /
00FA7F Return
00FA7F Return
00FA86  Don't respawn sprites
00FA8F Loop over sprites:
00FA91 \ If sprite status < 8,
00FA94  | skip the current sprite
00FA96 /
00FA98 \ If Mario carries a sprite past the goal,
00FA9A  |
00FA9C  |
00FA9D  | he gets a powerup
00FAA0  |
00FAA1 /
00FAA3 \ Branch if goal tape
00FAA6  |
00FAA8 /
00FAAA \ If sprite on screen...
00FAAD  |
00FAB0  |
00FAB2  | ...and "don't turn into coin" not set,
00FAB5  |
00FAB7  |
00FAB9  | Set coin animation timer = #$10
00FABB  |
00FABE  | Sprite status = Level end, turn to coins
00FAC0  |
00FAC3 /
00FAC5 \ If "don't erase" not set,
00FAC8  |
00FACA  |
00FACC  | Erase sprite
00FACE /
00FAD1 \ Goto next sprite
00FAD2 /
00FAD4 \
00FAD6  | Clear out all extended sprites
00FAD6 \ Clear extended sprite
00FAD8  |
00FAD8 /
00FADB  |
00FADC /
00FADE Return
00FB00 X = Mario's power up status
00FB02 \ If Mario has star, X = #$04.  However this never happens as $1490 is cleared earlier
00FB05  | Otherwise Mario could get a star from carrying a sprite past the goal.
00FB07  / Unreachable instruction
00FB07 / <--Unreachable, unused
00FB09 \ If Mario on Yoshi, X = #$05
00FB0C  |
00FB0E /
00FB10 \ If Spring Board, X += #$07
00FB13  |
00FB15 /
00FB17 \ If P Switch, X += #$07
00FB19 /
00FB1B \ If Key, X += #$0E
00FB1D /
00FB1F \ If Baby Yoshi, X += #$15
00FB21 /
00FB69 \ Sprite status = Goal tape power up
00FB6B /
00FB7F / Play sound effect
00FB8C Return
00FBA3 Return
00FBB3 Return
00FBD6 \ Use Palette A
00FBD8 /
00FBE4 Y = Index into sprite OAM
00FBEF Return
00FC0C  Bug: Sprites glitch if too many near goal tape.  See goalsprites.asm
00FC22 Return
00FC23  \ Unreachable instructions
00FC23 \ Unreachable
00FC25 / Status = Carried
00FC38 No Yoshi wings
00FC72 Return
00FC79 Return
00FC7C / Play sound effect
00FC8F \ X = First free sprite slot, #$03 if none free
00FC93  |
00FC94  |
00FC96 /
00FC98 \ Status = Normal
00FC9A /
00FC9D \ Sprite = Yoshi
00FC9F /
00FCA1 \ Yoshi X position = Mario X position
00FCA3  |
00FCA5  |
00FCA7 /
00FCAA \ Yoshi's Y position = Mario Y position - #$10
00FCAC  | Mario Y position = Mario Y position - #$10
00FCAD  |
00FCAF  |
00FCB1  |
00FCB3  |
00FCB5  |
00FCB7  |
00FCB9 /
00FCBC Reset sprite tables
00FCC5 \ Set Yoshi palette
00FCC8 /
00FCEB Return
00FCF4 Return
00FD07 Return
00FD19 \ Find a free extended sprite slot
00FD1B  |
00FD1E  |
00FD20  |
00FD21  |
00FD23 / Return if no free slots
00FD23 Return
00FD26 \ Extended sprite = Water buble
00FD28 /
00FD59 Return
00FD6A Return
00FD9C Return
00FE0D Return
00FE16 \ Extended sprite = Water bubble
00FE18 /
00FE71 Return
00FE93 Return
00FEA8 \ Find a free fireball slot (08-09)
00FEAA  |
00FEAD  |
00FEAF  |
00FEB0  |
00FEB2  |
00FEB4 / Return if no free slots
00FEB4 Return
00FEB4 Return
00FEB7 / Play sound effect
00FEBF \ Extended sprite = Mario fireball
00FEC1 /
00FF06 Return
00FF31 Return
00FF60 Return
00FF92 Return
